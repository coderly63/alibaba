## 1.原型和原型链是什么？

每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找...... 这个操作被委托在整个原型链上，这个就是我们说的原型链了。

## 2.new一个新对象的过程，发生了什么？

1. 创建一个空对象{}
2. 让该空对象的原型对象设为构造函数的函数对象
3. 改变对象内的this指向，指向该对象
4. 执行构造函数
5. 若构造函数没有手动返回对象，则返回创建的对象

## 3.session和cookie的区别

共同点：都是记录服务端与客户端会话状态的机制

1. cookie存储在客户端（一般为4kb），session存储在服务端（一般没有限制）
2. cookie存储在客户端不是很安全，别人可以本地cookie进行cookie诈骗，考虑安全应使用session
3. cookie只能存放字符串，而session可以存储各种类型
4. session存储在服务器会增大服务器的开销，使性能降低
5. session过期取决于服务器的设定，cookie是否过期是在生成的时候决定的
6. 浏览器禁用cookie后，session可通过url重写和表单隐藏域将sessionID带给客户端

## 4.localStorage和sessionStorage

1. sessionStorage仅在当前会话有用，localStorage除非手动清除，否则一直存在
2. 一般可存储5MB的信息

## 5.http和https

1. http为明文传输，https为具有安全性的SSL加密传输
2. https需要到ca申请证书，一般为收费的
3. http与https使用的两种完全不同的连接方式，用的端口也不一样，前者是80，后者是443
4. http的连接是无状态的，https是SSL和http协议构建的可进行加密传输，身份认证的网络协议，更安全

## 6.闭包

* 能够访问其他函数内部变量的函数，称为闭包
* 从外部也能访问到内部作用域的信息
* 由于对象所有属性和方法均可访问，造成了安全隐患，可通过闭包模拟出私有属性
* 闭包可能导致内存泄漏 
* js会定时清除没有被访问的那些变量，由于函数内部的变量始终被访问，所以一直不能被清除

## 7. 前端性能优化

1. 减少http请求（DNS查找，TCP握手，浏览器发出http请求，服务器接收请求并相应，浏览器接收响应）
2. gzip压缩
3. CDN托管
4. 浏览器缓存（强缓存，协商缓存）
5. 抽离封装组件
6. 操作样式时使用className而不是直接操作style
7. 图片预加载

## 8.HTTP1.0、HTTP1.1 和 引入了HTTP2.0 的区别

1. 在http1.0中主要使用if-Modified-Since,Expires作为缓存判断的标准，http1.1引入了更多的缓存控制策略，如Etag If-None-Match
2. 带宽优化
3. 错误通知的管理
   * 新增了24个响应状态码（409config，410Gone）
4. Host头处理
   * http1.0认为每台服务器绑定一个IP地址，因此，请求消息中的URL没有传递主机名，但随着虚拟技术的发展，一台服务器可以有多个虚拟主机，并且他们共享一个IP地址，所以HTTP1.1的请求消息和响应消息都支持Host头域，且如果请求消息中没有Host会报400错误
5. 长连接（线头阻塞）
   * 客户端与服务端进行TCP连接后，他们之间的连接会一直存在，不会因为一次http请求结束后就关闭，后序的请求也是用这个连接。
   * 长连接可以省去TCP的建立和关闭操作，对于频繁请求的客户端适合用长连接
6. 分块传送

   * http分块传送允许服务器为动态生成的内容维持http持久连接
   * 分段传输编码允许服务器在消息的最后发送消息头字段。对于那些头字段在内容被生成前无法知道的情形非常重要，例如消息的内容要使用散列进行签名
   * 服务器有时使用压缩（gizp）以缩短传输花费的时间，分段传输编码可以分隔压缩对象的多个部分，在这种情况下，块不是分别压缩的，而是整个负载进行压缩，有利于一边压缩一边传输数据

#### http2的新特性：

* 二进制分帧：在应用层（http）和传输层（tcp）增加一个二进制分帧层，在二进制分帧层上，http2.0会将传输的消息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，其中首部信息header封装到headers帧中，而request body将被封装到Date帧中。Http2.0通信都在一个TCP连接上，这个连接可以承载任意数量的双向数据流，相应的每个数据都以消息的形式发送，而消息由一个或多个帧组成，这些帧可以乱序发送，后可以通过帧首部的流标识重新组装。
* 首部压缩：在客户端和服务端使用首部表来跟踪和存储之前发送的键值对，对于相同的数据，不在通过每次请求和响应发送，而对于新的键值对，会将键值放在表的末尾或者替换之前的值。
* 多路复用：基于二进制分帧层，http2.0可以通过共享的TCP连接同时发送请求和响应。HTTP消息被被分解为独立的帧，交错发送，在另一端通过流标识和首部将他们重新组装起来。HTTP1.x中的长连接（线头阻塞），尽管管线化可以实现同时发送，但是服务端依然以此处理，然后响应。
* 服务端推送

## 9.说一说从输入URL到页面呈现发生了什么？

1. 构建请求
2. 查找强缓存
3. DNS解析
4. 建立TCP连接
5. 发送http请求

## 10.重绘和回流（重排）

> 当Render Tree中部分或全部元素尺寸，结构，或者某些属性发生改变的时候，浏览器重新渲染部分或者全部文档的过程叫做回流
>
> > 首次渲染
> >
> > 浏览器窗口大小改变
> >
> > 元素尺寸或位置发生改变
> >
> > 元素内容变化
> >
> > 元素字体大小变化
> >
> > 添加删除可见的DOM元素
> >
> > 激活CSS伪类
>
> 当页面中元素样式的改变不影响它在文档流中的位置时，浏览器会将新样式赋予给该元素并重新绘制它，这就是重绘

* 回流必然导致重绘，重绘不一定导致回流

* 如何避免？如何优化？

1. 将动画效果放在position为absolute或fixed的元素上
2. 频繁读取会引发回流/重绘的属性时，可以先保存下来
3. 分离读写操作，因为每次读取DOM元素相关属性都会引起回流
4. 样式集中改变
5. 离线改变DOM，先使其display属性为none
6. 对于复杂的动画，使它脱离文档流，否则会引起父元素及相关元素频繁回流

## 11.get和post的区别

1. get请求参数一般放在url中，post请求一般放在body中
2. get请求对长度有限制，一般为浏览器或者服务端设置，而post一般没有
3. get产生一个数据包，post产生两个数据包（先发送请求头，在发送请求体）
4. get请求可直接在浏览器中打开
5. get请求会被浏览器主动缓存下来，而post默认不会

## 12.MVC，MVP，MVVM

这三种流行的设计模式主要都是在解决数据和视图逻辑的分离问题

* MVC对数据进行了第一步的分离，实现简单，但view，model的分离不够彻底
* MVP通过Presenter彻底解耦了View和Model，同时剥离了业务逻辑和底层数据逻辑，Model变的稳定，但是当业务逻辑复杂的时候，Presenter就会变得臃肿
* MVVM通过数据劫持+发布订阅模式，依靠的是ES5提供的Object.defineProperty实现。


## 13.XSS和CSRF

> XSS分为存储型和反射型
>
> * 存储型
>
> > 1. 攻击者将恶意代码提交到目标网站数据库中
> >
> > 2. 用户打开目标网站后，网站服务端将恶意代码从数据库中取出，拼接到HTML中返回给浏览器
> > 3. 用户浏览器收到响应后解析执行，恶意代码也被执行
> > 4. 恶意代码窃取用户数据并发送到攻击者服务端，或者冒充用户，调用目标网站接口执行攻击者指定的操作
>
> * 反射型
>
> > 1. 攻击者构造出特殊的URL，其中包含恶意代码
> > 2. 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器
> > 3. 用户浏览器收到响应后执行恶意代码
> > 4. 恶意代码窃取用户数据并发送到攻击者服务端，或者冒充用户，调用目标网站接口执行攻击者指定的操作
>
> * DOM型
>
> > 1. 攻击者构造出特殊URL，其中包含恶意代码
> > 2. 用户打开恶意代码的URL
> > 3. 用户浏览器收到响应后解析执行，JS取出URL中的恶意代码并执行
> > 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
>
> CSRF
>
> > 攻击者诱导用户进入第三方网站，在第三方网站中，向被攻击者网站中发送跨站请求，利用受害者在被攻击网站已经获取的COOKIE凭证，绕过后台的用户验证，达到冒充用户对被攻击者网站执行某项操作

XSS攻击如何防范？

* 对用户的输入进行检查，过滤，转义，对特殊字符进行过滤和编码（如< >）
* 在变量输出到HTML页面时，可以对字符编码，转义
* 对于连接跳转，如 <a href="xxx" 或 location.href="xxx"，要检验其内容，禁止以 javascript: 开头的链接
* 设置httpOnly防止js访问获取Cookie

CSRF攻击如何防范？

* 验证码
* Referer，记录该http请求来源，不过该属性可以修改，只能辅助判断
* 添加token验证
* 谷歌新增属性samesite（该属性可以让Cookie在跨站请求时不会被发送）

samesite:

1. strict：只有当前网页URL与请求URL完全一致时，才会携带Cookie
2. lax（默认）：允许第三方网站请求携带Cookie
3. None：无论是否跨站都会携带Cookie

## 14.Vue和React的区别

1. ##### 监听数据变化的实现原理不同

Vue通过getter/setter进行数据劫持，能精确知道数据变化并进行相应渲染

React是在setState中通过比较引用的方式进行的

2. ##### 数据流的不同

* Vue中组件与DOM中的值可以通过v-model双向绑定
* React一直不支持双向绑定

3. ##### HOC和Mixins

* Vue组合不同功能是通过Mixins
* React通过HOC实现高阶组件

4. ##### 组件通信的区别

* Vue一般父组件通过props向子组件传递数据或者回调，一般只传数据，通过事件的机制来处理子组件向父组件的通信。provide/inject可实现父组件跨越多个层级向子组件传递数据
* React父组件通过props可像子组件传递数据或者回调，可通过context进行跨层级的通信，与provide/inject相似

5. ##### 模板渲染方式不同

* Vue通过一种拓展的HTML语法进行渲染，是在和组件JS代码分离的单独模板中通过指令实现的，如v-for，v-if
* React通过JSX渲染模板，在组件JS代码中，通过原生JS代码实现如循环，条件等

6. ##### Vuex和Redux

* Vue中$store被注入到了所有组件实例当中，因此使用比较灵活，使用dispatch或commit提交更新，通过mapstate或者this.$store来读取数据。Vuex中的数据是可变的，可以直接修改，通过getter/setter检测数据变化
* Redux中每一个组件都需要显示的用connect把需要的props和dispatch连接起来。Redux中的数据是不可变的，每次是用新的state替换旧的state，通过diff算法比较差异

7. Vue通过模板语法优化代码，React通过Fiber机制优化代码（重写requestIdleCallback API）

## 15. HTTPS加密原理（SSL）

1. 客户端生成一个随机数，然后传输到服务端，并且会带上客户端所支持的所有加密套件
2. 服务端接收到后，会产生一个新的随机数，会随着证书一起传输给客户端
3. 客户端接收到后会验证证书的合法性，然后用证书中的公钥加密新生成的随机数生成预主密钥，传输给服务端
4. 服务器用自己的私钥解密，就得到了预主密钥
5. 最终服务端会选择一个最合适的加密套件，两边同时使用这个加密套件，对这三个随机数通过算法生成一个主密钥，随后的信息传输都通过主密钥进行加密解密

## 16. TCP和UDP的区别

1. 连接方面：TCP是面向连接，UDP是无连接的
2. 安全方面：TCP提供可靠的服务，保证传输的数据无差错，不丢失，不重复，且按序到达。UDP则不保证可靠传输
3. 传输效率：TCP传输效率相对较低，UDP相对较高

## 17.三次握手和四次挥手

* 三次握手：

  刚开始客户端处于closed状态，服务端处于listen状态

1. 第一次握手，客户端发送一个SYN报文请求连接，并随即生成一个初始化序列号ISN，此时客户端处于SYN_SEND状态
2. 第二次握手，服务端接收到客户端的SYN报文后，会以自己的SYN作为应答，并指定了自己的初始化序列号ISN，同时把客户端传来的ISN+1作为ACK的值发送给客户端，此时服务端处于SYN_REVD状态
3. 第三次握手，客户端接收到SYN报文后，把服务端的ISN+1作为ACK的值返回，表示已经接收到了服务端的SYN报文，此时客户端处于ESTABLISHED状态
4. 服务端接收到了ACK报文后，也处于ESTABLISHED状态

* 四次挥手

  刚开始双方都处于ESTABLISHED状态

1. 第一次挥手，客户端发送一个FIN报文请求关闭连接，报文中会指定一个序列号，此时客户端处于FIN_WAIT1状态
2. 第二次挥手，服务端收到FIN报文后，会发送ACK报文，并且把客户端的序列号+1作为作为ACK的值，表示已经收到客户端的请求了，此时服务端处于CLOSE_WAIT状态。此时TCP处于半关闭状态，客户端到服务端的连接释放，客户端收到服务端的响应后，进入FIN_WAIT2状态，等待服务端发送FIN报文。
3. 第三次挥手，如果服务端也想断开连接后，服务端发送一个FIN报文，并制定一个序列号，此时服务端处于LAST_ACK状态
4. 第四次挥手，客户端收到FIN报文后，一样把服务端的序列号+1作为ACK的值传给服务端，此时客户端处于TIME_WAIT状态。此时会一直等待确保服务端接收到自己的ACK报文之后进入CLOSED状态
5. 服务端收到客户端的ACK报文之后，进入CLOSED状态

## 18. 常见的状态码

1. 200 OK
2. 201 Created （请求成功，资源已创建）
3. 202 Accepted （收到请求未响应）
4. 204 NO CONTENT（请求处理成功，但没有资源返回）
5. 301 Moved Permanently 永久性重定向
6. 302 Found 临时重定向
7. 304 Not Modified 协商缓存
8. 400 Bad Request 请求报文存在错误 服务器无法理解
9. 401 Unauthorized 未认证
10. 403 Forbidden 不允许访问额
11. 404 Not Found

## 19. ES6的新特性

1. 声明
   * const声明常量
   * let声明变量
2. 解构赋值
   * 数组对象结构
3. 字符串扩展
   * for-of遍历
   * 增强字符串模板`${}`
   * 很多方法
4. 箭头函数
5. Set数据结构
6. Promise（async，await）
7. Class
8. rest参数
9. 新的Module体系（之前CommonJS）

## 20.CommonJS和ES6Module的区别

1. CommonJs模块是运行时加载（动态导入），ES6模块是编译时输出接口（静态导入）
2. CommonJs模块导出的是对象的拷贝，而ES6Module导出的是值的引用

## 21.浏览器渲染机制

1. 解析html生成DOM树，解析CSS生成CSS规则树，等待JS文件加载后，通过DOM API和CSSOM API来操作DOM Tree 和 CSS Rule Tree
2. 解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree来构造Rendering Tree
3. 最后通过调用操作系统Native GUI的API绘制

#### 原理：

* 浏览器从磁盘或网络读取字节数据，然后根据指定的编码（如UTF-8）将字节转化为字符串
* 接着将字符串转化为token，token会标识当前是开始标签或是结束标签或是文本数据
* 生成节点对象并构建DOM

## 22.call，apply，bind的区别

* call 接收多个参数，第一个为函数上下文也就是this，后边参数为函数本身的参数
* apply接收两个参数，第一个参数为函数上下文this，第二个参数为函数参数只不过是通过一个数组的形式传入的
* bind 接收多个参数，返回的是一个新函数

## 23.js设计模式

* 工厂模式
* 单体模式
* 模块模式
* 代理模式
* 职责链模式
* 

## 24.CDN / MDN

`CDN` 全称 `Content Delivery Network`，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定

## 25.iterable

iterable是ES6新引入的类型，Array，Map，Set都是iterable类型

引入iterable类型的原因是简化迭代的过程，并且for...in会将额外的属性遍历出来

含有Symbol.iterator属性(函数)即是可迭代能力的对象的集合

## 26.webpack/Vite

#### 打包原理：

1. 读取webpack配置文件，获取配置参数
2. 启动webpack，创建Compiler对象并解析项目
3. 从入口文件entry开始解析，并找到其导入的依赖模块，递归遍历分析，形成依赖关系树
4. 对不同文件类型的依赖模块文件使用对应的Loader进行编译，最终转化为JS文件
5. 整个过程会通过发布订阅模式，向外抛出一些hooks，而webpack插件会监听这些事件节点，执行插件任务从而达到干预输出的问题。

更细致的原理：

* @babel/parser：将源码转化为AST语法树
* @babel/traverse：对AST语法树进行递归遍历，然后收集所有依赖
* babel-core：将ES6的AST语法树转化为ES5
* 重写require函数，在严格模式下使用eval执行每个模块提取出的代码
* 增加export对象，最后将export对象返回出去

#### sourceMap是什么：

sourceMap是一项将编译，打包，压缩后的代码映射回源代码的技术，由于打包后的代码没有阅读性，一旦在开发中出现bug，直接在压缩后的代码中debug会非常糟糕，sourceMap会快速定位到源代码的位置，提高开发以及debug效率。由于是一种源码的映射，所以就必然有一份映射的文件，来标记压缩代码对应的源码的位置，通常映射文件以.map结尾。

#### 编写Loader：

由于webpack最后打包出来的代码都是JS代码，实际上在webpack内部也只能处理JS模块代码，在打包过程中，会默认把所有遇到的文件都当做JS来解析，因此当项目存在非JS代码时，我们需要对其进行必要的转换，才能继续执行打包任务。

Loader是支持以数组的形式配置多个的，因此webpack在转化该类型文件时，会按顺序链式调用每一个Loader，前一个Loader返回的内容会作为下一个Loader的入参，因此Loader开发存在规范，返回值必须是标准的JS代码字符串，以保证下一个Loader能够正常工作。

#### 编写Plugin

Loader负责文件转化，Plugin负责功能扩展，都是webpak的重要组成部分。

webpack基于发布订阅模式，会在运行过程中广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现想要的功能。

需要遵循的规范：

* 插件必须是一个函数或者一个包含apply方法的对象，这样才能访问complier实例
* 传给每个插件的compiler和compilation对象都是同一个引用，若在一个插件中修改了他们身上的属性，会影响后面的插件
* 异步的事件需要在插件处理完任务时调用回调函数通知Webpack进入下一个流程。

#### 优化性能

* 优化打包速度
  1. 设置production模式，开启tree shaking和uglifyjs
  2. 设置alias，可以直接告诉webpack去哪个路径找文件，减少寻找文件的时间
  3. 设置include和exclude减少webpack loader搜索转化时间
  4. 设置noPrase可以告诉webpack对该模块无需解析（该依赖库不需要其他配置）
  5. 设置extensions，webpack会根据定义的后缀查找文件
  6. 开启happyPack开启多进程Loader转化
  7. 增强代码压缩
  8. 抽离第三方模块
  9. 配置缓存
* 优化打包体积
  1. 使用externals将不需要打包的静态资源抽离出去
  2. 开启tree shaking

#### 两者的区别

* webpack首先要对所有文件进行打包，然后启动dev-server，请求服务器时直接返回结果。而vite是直接启动服务器，当请求某个模块时，再对模块进行实时编译。
* 由于现代浏览器对ES Module的天然支持，vite充分利用这一点，将浏览器所需要的文件编译后直接返回，这是按需动态编译，极大地缩减了编译时间，项目越复杂，模块越多，vite优势越明显
* HMR方面，webpack需要将该模块的相关模块全部编译一次，而vite只需要浏览器请求新的模块即可

#### Vite原因

* 浏览器开始原生支持 ES 模块
* esbuild依赖预构建（将commonjs转化为ES，将有许多内部模块ESM关系转换为单个模块，避免大量网络请求造成阻塞）
* 热更新时，Vite4只需要精确地使已编辑地模块与最近地HMR边界之间地链失活，无论应用多大，都能快速更新
* 利用HTTP头来加速整个页面的重新加载（304协商缓存，cache-control强缓存）

## 27. DNS解析

1. 检查浏览器缓存
2. 检查操作系统缓存， 如hosts文件夹
3. 检查路由缓存
4. 如果前几步都没找到，那么会向ISP的LDNS服务器查询
5. 如果LDNS服务器未找到，会向根域名解析器请求解析，分为以下几步：
   * 根服务器返回顶级域名（TLD）服务器如.com .cn .org的地址
   * 接着向TLD发送请求，获得次级域名（SLD）服务器地址
   * 接着向SLD域名服务器查询目标IP，返回IP地址
   * Local DNS Server会缓存结果，并返回给用户，缓存在系统

## 28.CDN

Content Delivery Network  -- 内容分发网络

* 根据DNS域名解析得到全局负载均衡系统（GSLB）的IP地址
* 本地DNS再向GSLB发出请求，GSLB的主要功能是根据本地DNS的IP判断用户的位置，筛选出距离用户最近的本地负载均衡系统（SLB），并将SLB的IP地址返回给本地DNS
* 本地DNS将SLB的IP地址发给浏览器，浏览器向LBS发出请求
* SLB根据浏览器请求的资源和地址，选出最优的缓存服务器发给浏览器
* 浏览器再根据SLB发回的地址重定向到缓存服务器
* 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器，如果没有，就向源服务器请求资源，再将资源发给浏览器并缓存在本地

#### CDN系统的组成

* 分发服务系统

  负责直接响应用户的访问请求，把缓存在本地的内容快速提供给用户，同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并缓存在本地。

* 负载均衡系统

  这要功能是负责对所有发起服务请求的用户进行访问调度，提供给用户最终访问地址

* 运营管理系统

  分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集，整理等工作

## 29.垃圾回收机制

#### 标记清除法：

* 垃圾收集器会在运行时给所有变量加一个标记，假定内存中所有都是垃圾（标记为0）
* 然后从根节点遍历，将不是垃圾的点标记为1
* 清除所有标记为0的垃圾，撤销并回收他们所占用的空间
* 最后把内存中的变量标记为0，等待下一次GC

​	缺点：清除之后剩余对象内存位置是不变的，会导致空闲内存空间是不连续的，出现了内存

碎片。分配速度慢

#### 标记整理：

* 在每次标记清除后，都会将活着的内存向前移动，清理掉边界的内存

#### 引用计数：

* 当一个变量被引用时，给变量引用次数加1，当引用次数为0时，就清理掉该对象

​	缺点：循环引用

#### V8对GC的优化：

##### 分代式垃圾回收：

* 将堆内存分为新生代和老生代两区域，采用不同的策略进行垃圾回收
* 将新生代分为使用区和空闲区，新加入的对象会放到使用区，使用区快满的时候，进行GC，回收器会对使用区的对象进行标记，标记完成后，将使用区的活动对象复制到空闲区进行排序，随后进行垃圾清理，最后将两个分区交换。
* 当一个对象反复被复制后依然存活，就将该对象复制到老生代中，使用老生代的策略进行管理。

并行回收	增量标记（三色标记）	惰性清理	并发回收

## 30.node事件循环

* 定时器检测阶段（timers）：执行setTimeout和setInterval的回调
* I/O事件回调阶段（I/O callbacks）：上一轮循环中未被执行的一些I/O回调
* 闲置阶段（ prepare）：系统内部使用
* 轮询阶段（poll）：检测新的I/O事件，执行与I/O相关的回调，（除了计时器和setImmediate()的调度之外），其余情况node将在此阻塞
* 检查阶段（check）：执行setImmedidate的回调
* 关闭事件回调阶段（close callback）：关闭回调执行，如socket.on("close", ...)

node11之前每个阶段完成后都会去检查nexttick队列，node11之后nexttick为微任务，每执行一个宏任务就对应执行相应的微任务

## 31.node进程通信

父进程在创建子进程之前，会创建IPC通道并监听它，然后创建出子进程，这个过程也会通过环境变量告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程间的通信。

## 32.SPA页面的理解

仅在web页面初始化的时候加载相应的三大件，一旦页面加载完成，SPA页面不会因为用户的操作而进行重新加载或跳转，取而代之的是用路由机制（hashChange, pushState, replaceState, popState）实现HTML内容的变化，避免页面重新加载。

## 33.计网模型

应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

## 34.拥塞控制原理

当网络情况比较差的时候，容易发生丢包的情况，主要有三个方法

* 慢启动阈值 + 拥塞避免

  一个比较保守的慢启动算法来适应网络，在开始传输的一段时间内，发送端和接收端会通过三次握手建立连接，确定各自接收窗口的大小，然后初始化拥塞窗口，接着每经过一轮收发时延，拥塞窗口翻倍，直到达到慢启动阈值。

  拥塞避免：之前每一轮RTT，拥塞窗口翻倍，现在每一轮加一个。

* 快速重传

* 快速恢复

  将拥塞阈值降低为拥塞窗口的一半，然后拥塞窗口大小变为拥塞阈值，接着拥塞窗口线性增加，以适应网络情况。

## 35.事件冒泡和阻止默认事件

* event.preventDefault 	
* event.stopPropagation

## 手写深克隆

## 36.Websocket

* 客户端升级/服务端升级：

  Connection: Upgrade 

  Upgrade: websocket

* 优点：

  支持双向通信，更灵活，更高效，更好的二进制支持
  
* Websocket之前是采用轮询Polling阶段，每隔一段时间连接一次

* 改进版的长轮询Long Polling阶段，在客户端给服务端发送请求后，如果没有消息会一直等待，当有新消息才返回。

## 37.V8引擎

* 由解析器通过词法分析（找出语法错误），语法分析将js代码转化成AST抽象语法树，再由基线编译器将AST转化为字节码文件，当字节码满足一定条件时，由优化编译器对字节码文件进行优化。
* 解析代码需要时间，所以JS引擎会避免完全解析源代码，另一方面，像是用户交互事件相关代码并不需要开始就全部解析，所以主流浏览器都采用惰性解析。解析器并不将所有函数都生成AST抽象语法树，而是通过预解析检查代码中的语法错误并抛出异常。
* 预编译分为全局预编译和函数预编译，全局预编译中，会创建GO（执行上下文）对象，找到变量，将变量名作为GO对象的属性名，并给该变量分配内存空间，赋值为undefined，找到function函数声明，将值赋予函数体。函数预编译中，创建AO对象，找到形参和变量，并将形参和变量名作为AO对象的属性名，分配内存空间，赋值为undefined，在将形参和实参统一，找到函数声明，值赋予函数体。
* V8引入JIT（即时编译）技术，通过基线编译器将代码快速生成字节码进行执行，字节码是机器码的抽象，如果字节码的设计与物理CPU的计算模型相同，那么字节码转为机器码非常容易。字节码可以被优化编译器用于生成图，避免优化编译器需要重新对JS文件编译解析再优化。
* 对于特定的程序逻辑，其变量类型和运行环境往往是固定的，正因为如此，V8引入了类型反馈技术，对于重复执行的代码，如果变量类型和运行环境多次相同，V8就会假设之后的类型也是相同的，并对代码进行优化，优化后的代码会保留类型检查，当下次类型相同时，V8会直接执行优化后的代码，但是当类型改变时，V8将会撤销之前的优化，也就是去优化，这是非常消耗性能的，所以避免变量类型反复改变。

## 38.数字签名与数字证书

* 数字签名：发送方将电子文档Hash运算，得到摘要，然后将摘要用私钥加密，得到数字签名，数字签名与电子文档一起发送给接收方，接收方收到后，同样将电子文档Hash运算，得到摘要，然后将数字签名用公钥解密与摘要进行对比，相等则校验通过。
* 数字证书是为了配合数字签名的辅助手段，用于保证解密数字签名的公钥的合法性，保证公钥没有被掉包。攻击者可能替换掉接收方的公钥，然后用自己的私钥处理更改后的文档，也会得到校验通过的结果。（权威的CA机构的数字证书）

## 39.fetch和axios的区别

* fetch为原生浏览器内部API，axios需要引入axios库
* 当接收错误的状态码时，fetch返回的promise并不会被标记为reject，而是resolve，但是resolve的返回值的ok属性会为false。
* 默认情况下，fetch并不会携带和接收cookie，需设置crendentails，（axios和XML都为withCredentials）
* fetch可以设置mode为"no cors"

## 40.React Hooks

#### 类组件的不足：

* 状态逻辑难以复用：想要复用组件需要用到render props（渲染属性）和HOC（高阶组件），一般都需要在原先组件外包裹一层父容器，导致层级冗余
* 复杂难以维护：生命周期中的函数过于分散
* this指向问题：一般函数需要写成箭头函数

#### Hooks的缺点

* useEffect依赖某个状态的变化，该变化可能又依赖其他状态，形成一条依赖链，一旦这个依赖链某个节点发生变化，这个useEffect可能就被意外触发了

#### Hooks：

* useState：声明一个状态变量，该函数接收的参数是状态的初始值，返回一个数组，第0项是当前状态值，第一项是改变状态的函数
* useEffect：副作用函数，用于模拟componentDidMount，componentDidUpdate和componentWillUnmount三个生命周期函数钩子。为了组件复用以及相互独立，一般每一个副作用一个useEffect钩子。在组件渲染以及更新时，useEffect钩子函数每次都会执行，并且会执行函数内部返回的函数，useEffect返回的函数的作用相当于componentWillUnmount。并且可以再useEffect函数传入第二个数组参数，只有当数组中包含的状态发生改变时，useEffect才会执行，否则跳过。
* useReducer：和redux中的redux类似，useState内部就是靠useReducer来实现，是一种useState的替代方案。接收一个形如（state，action）=> newState的reducer，并返回当前的state以及相对应的dispatch方法。
* useCallback：接收一个回调函数和一个依赖数组（子组件依赖父组件的状态），会返回一个memoized版本，该回调函数仅在依赖状态改变时才会更新。一般与React.Memo配合使用，Memo会包裹一个函数组件，如果状态不改变则不进行刷新
* useMemo：接收一个函数和依赖数组，只有当依赖状态改变时才会改变memoized的值，一般用于缓存复杂的计算结果，避免每次组件刷新的时候重复计算
* useContext：用于接收和订阅上层最近的<MyContext.Provider>的value，当上层provide更新时，该hook会重新渲染。

## 41.前端工程化

* 技术选型（如React，Vue，Angular）
* 统一规范：规范的代码格式可以促进代码规范，降低维护成本，代码审查
* git规范：一般项目分主分支和其他分支，当团队要开发新功能时，就从master分支新开一个分支，开发完再合并回master分支。commit规范（如提交类型type）
* 项目规范：项目的组织方式和命名方式（public：公共资源，assests：静态资源，router：路由，store：vuex，utils：工具函数，views：页面）
* UI规范
* 测试

## 42.nextTick

* Vue是异步执行DOM更新。只要观察到数据的改变，Vue内部将会开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个watcher被多次触发，只会被推入队列中一次。这种缓冲在去除重复数据和重复的DOM操作非常重要。

* 通过timerFunc函数来选择queue队列是宏队列还是微队列，从上往下依次适配，setImmediate，MessageChannel，Promise，settimeout
* 如果Vue使用setTimeout等宏任务函数，那么势必要等待UI渲染完成后的下一个宏任务执行，而如果使用微任务函数，无需等待UI渲染完成才进行nextTick回调，可以想象势必会在JS引擎和GUI渲染线程来回切换，以及等待GUI渲染过程。
* Vue内部会通过nextTick函数将flushScheduleQueue（watcher视图更新）函数以及nextTickHandler函数（nextTick函数回调）加入到任务队列中，

## 43.浏览器进程

1. Browser进程（负责浏览器界面展示，与用户交互，前进后退等，创建销毁其他进程，网络资源管理，下载等）
2. 第三方插件进程
3. GPU进程（绘制3D）
4. 浏览器渲染进程（默认每个tab页一个进程，互不影响，页面渲染，脚本执行，事件处理）

#### 浏览器多进程的优势：

* 避免某个tab页崩溃后影响整个浏览器
* 避免第三方插件崩溃后影响整个浏览器
* 充分利用多核优势

#### 浏览器渲染进程

1. GUI渲染线程
   * 构建Render Tree，布局，绘制
   * 页面重绘和回流
   * 与JS引擎互斥
2. JS引擎线程
   * 负责处理JS脚本
   * 每个tab页（渲染进程）一个js线程
3. 事件触发线程
   * 用于控制事件循环
   * 用于将定时器结束的回调加入事件队列
   * 将事件的触发条件满足时，该线程会把回调加入事件队列中
4. 定时器触发线程
   * 对计时器进行计时，到时候交给事件触发线程处理
   * 间隔一般为4ms
5. 异步http请求线程
   * 像ajax或者XMLHttpRequest连接后新开一个线程线程请求
   * 检测状态变更，并交给事件触发线程处理

## 44.js继承方式

1. 组合继承（借用构造函数继承和原型链继承）

```js
function Father(name){
	this.name = name;
	this.colors = ["red","blue","green"];
}
Father.prototype.sayName = function(){
	alert(this.name);
};
function Son(name,age){
	Father.call(this,name);//继承实例属性，第一次调用Father()
	this.age = age;
}
Son.prototype = new Father();//继承父类方法,第二次调用Father()
Son.prototype.sayAge = function(){
	alert(this.age);
}
```

2. 原型继承（以空对象作为媒介）

```js
function object(obj){
  function F(){}
  F.prototype = obj;
  return new F();
}
```

3. 寄生式继承（在原型继承的基础上，增强对象，返回构造函数）

```js
function createAnother(original){
  var clone = object(original); // 通过调用 object() 函数创建一个新对象
  clone.sayHi = function(){  // 以某种方式来增强对象
    alert("hi");
  };
  return clone; // 返回这个对象
}
```

4. 寄生组合式继承

```js
function extend(subClass,superClass){
	subClass.prototype = Object.create(superClass.prototype);//指定对象
    subClass.prototype.constructor = subClass;//增强对象
}
```



## 45.HashRouter和HistoryRouter

* HashRouter主要通过location.hash改变路由的hash值，然后通过hashChange监听hash的改变执行响应的处理比如重新渲染界面
* HistoryRouter主要通过history.pushState和history.replaceState实现对路由的更改但不刷新界面，由于popState并不能监听到pushState和replaceState Api的调用，所以需要通过重写这两个函数完成相应功能。

## 46.Set，weakSet，map，weakMap

Map和Object的区别

* 在Object对象中只能把String和Symbol作为key的值，在Map中，key可以是任何基本类型（Number，String，Boolean，undefined），或者对象（Object，Map，Set，Function）
* Map中有size属性，Object只能通过手动计算（Object.keys(obj)）

## 47.JWT

* header：声明类型和加密的算法

```js
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

2. payload：声明

```js
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

3. signature：签名（该部分需要base64加密的header和payload，然后通过header声明的加密方式进行加盐secert加密，构成第三部分）

## 48.选择器权重

1. !important：正无穷
2. 内联选择器：1000
3. ID选择器：100
4. 类选择器，属性选择器，伪类选择器：10
5. 标签选择器，伪元素选择器：1

## 49.箭头函数

1. 箭头函数没有原型（prototype），所以没有this指向
2. 箭头函数的this指向定义时的第一个普通函数
3. 不能直接修改箭头函数的指向（如bind，call，apply）
4. 箭头函数外层如果没有普通函数，严格模式和非严格模式都指向window

何时不能用箭头函数？

* 定义对象方法
* 定义构造函数方法（new）
* 定义原型方法
* 定义事件回调
* 无法转化为generator函数

## 50.Vue3新特性

1. Composition API
2. 生命周期钩子（将beforeCreated和created改为setup）
3. 响应式原理
4. 更好的tree-shaking

## 51.CSS动画

1. transition（过渡，使元素属性从一个属性的某个值变为另一个值，这就是一种状态的改变，比如我们平时用的:hover,:foucs,checked，js）
   * transform：translate，scale，rotate
   * transition需要外力触发，比如hover，无法自动发生并且是一次性的
   * 只能定义开始和结束状态，不能定义结束状态
2. animation（动画，是transition属性的扩展，弥补了很多不足，比如可以定义中间状态，无限循环）

## 52.computed和watch的区别

* computed计算出的属性，他会根据所依赖的数据动态显示新的运算结果，该计算结果会被缓存起来，当依赖项发生改变时，会重新计算新的结果。
* watch会监听数据的改变，当数据发生改变时，会执行响应的回调，immediate可以设置数据由无到有的过程被监听，默认不监听，deep属性可以监听对象内部属性的改变。

## 53.addEventListenr

* capture：Boolean，在事件捕获阶段触发，默认为false
* once：Boolean，在触发一次之后，移除listener
* passive：Boolean，设置为true时，表示listener永远不会调用preventDefault()，如果listener还是设置了，客户端会忽略他并抛出一个警告。

## 54.Socket和Http区别

* Http连接使用的是请求响应式，只有客户端发送请求时，服务端才能返回数据。
* Socket通信则是在双方建立连接后，可以直接进行数据传输，在连接时2可以主动推送消息，而不需要客户端的请求。
* Socket又叫套接字，在程序内部提供了与外界通信的端口，即端口通信。
* Socket是一种抽象层（介于应用层和传输层之间），是为了使用TCP/UDP而抽象出来的一层API，是对TCP/IP的封装，应用程序通过Socket来发送和接收数据，使用Socket可以将应用程序添加到网络中，与处于同一网络的其他应用程序通信。

## 55.数组API

* of
* slice：浅拷贝数组的元素
* splice：从制定位置删除数据，返回被删除的数组，改变原数组
* sort：排序
* pop，push，shift，unshift，reverse
* join，concat，indexOf
* forEach，every（用于判定数组所有元素是否都符合条件），some（判断是否有满足的条件），filter（过滤原数组，返回新数组），map（对每个元素处理，返回新的数组），reduce（为元素提供累加器），find&findIndex（找到数组成员）

## 56.CSS样式隔离

1. CSS modules
2. CSS in js

## 57.Number

* JS是以IEEE-754标准存储的双精度浮点数类型，双精度浮点数共有64位，第一位用于表示符号，接着11位表示阶码，剩余52位表示尾数。
* 阶码表示的是2的多少次方，尾数表示的是小数点后面的部分

## 58.首屏渲染优化

* 懒加载（vue路由懒加载）
* 使用字体图标
* 对于体积较大的资源，使用CDN静态资源
* 启用gzip压缩
* 服务端渲染
* 骨架屏

## 59.H5新特性

* 语义化标签（article, aside, header, footer, nav等）
* 音频视频（audio，video）
* Canvas
* GeoLocation（用户同意后可返回地理位置）
* Postmessage API（跨文档消息通信，可以确保iframe，标签页，窗口安全的跨源通信，使用window.postMessage和window.addEventListener("message")实现通信）
* WebSocket（全双工通信管道，仅通过socket实现通信，客户端与服务端最初握手时，将HTTP协议升级到WebSocket协议）
* Forms API（url，tel，email，placeholder）
* 拖放API（draggable）
* WebWorker（JS为单线程，在浏览器进程中新开一个线程用于计算）
* WebStorage API（sessionStorage，localStorage）

## 60.git rebase和git merge的区别

#### git merge：

* 只处理一次冲突
* 引入了一次合并的历史记录，合并后所有commit都会按照提交时间从新到旧排列
* 过程信息更多，提高了查找问题难度

#### git rebase

* 改变当前分支从master上拉出的位置
* 没有多余的历史合并记录，且合并后的commit顺序不一定按照commit的时间排列
* 可能会多次解决一个地方的冲突

## 61.中间件

* 中间件本身是一个函数，在收到请求和返回响应的过程中做一些我们想做的事。
* 修改请求和响应对象。终结请求和响应循环。调用堆栈中的下一个中间件

## 62.热更新原理

* 浏览器会与服务器web-dev-serve通过websocket进行双端通讯
* 当修改本地代码后，服务器会通知浏览器，会发起两个请求，一个是JSON（本次新生成的Hash值，用于作为下次热更新的标识。当前热更新对应的模块）。另一个是js（重新编译打包后的代码，用于替换模块）

## 63.React合成事件

* 如果DOM上绑定了过多的事件，整个页面响应以及内存应用都可能受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层浏览器之间事件系统差异，实现了一个中间层
* 比如onClick，React并不会将click事件绑定在真实DOM上，而是在document处监听所有支持的事件，后React会将事件内容封装并交由真正的处理函数执行

## 64.H5拖拽

* 被拖动的元素：dragstart -> drag -> dragend
* 目的地对象：dragenter -> dragover -> dragleave
* 释放：drop

